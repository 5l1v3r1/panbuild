#!/usr/bin/env python3
import yaml
import json
import sys

# Snapcraft top-level metadata
# See https://snapcraft.io/docs/snapcraft-yaml-reference for the full YAML reference.
# TODO is https://snapcraft.io/docs/snapcraft-advanced-grammar relevant?
# TODO is it worth it to download and use
# https://github.com/snapcore/snapcraft/blob/master/schema/snapcraft.json ???
# The top-level keys and values in snapcraft.yaml provide the snap build process, and the store,
# with the overarching details of a snap. See Snapcraft app metadata and Snapcraft parts metadata for
# details on how apps and parts are configured within snapcraft.yaml.
# Top-level details include a snap’s name, version and description, alongside operational values
# such as its confinement level and supported architecture.
SNAP_MANIFEST_TOP_LEVEL_TAGS = [
    # Type: string (optional)
    # Incorporate external metadata via the referenced part.
    # See Using external metadata for more details.
    "adopt-info",

    # Type: list[object] (optional)
    # List of build and run architectures.
    # For more details, see https://snapcraft.io/docs/architectures
    "architectures",

    # Type: list[string] (optional)
    #
    # A list of features that must be supported by the core in order for this snap to install.
    #
    # For example to make the snap only installable on certain recent version of snapd(like 2.38) you can specify:
    #   assumes:
    #   - snapd2.38

    # Other potential values for assumes include:
    #   common-data-dir: support for common data directory across revisions of a snap.
    #   snap-env: support for the “Environment:” feature in snap.yaml
    #   command-chain: support for the “command-chain” feature for apps and hooks in snap.yaml
    "assumes",  # ⚓

    # Type: string (optional)
    #
    # A snap of type base to be used as the execution environment for this snap.
    # See https://snapcraft.io/docs/base-snaps for further details.
    #
    # Values:
    #   bare	Empty base snap, useful for fully statically linked snaps and testing
    #   core	Ubuntu Core 16
    #   core18	Ubuntu Core 18
    #   core20	Ubuntu Core 20
    "base",

    # Type: enum (optional)
    #
    # Determines if the snap should be restricted in access or not.
    #
    # Possible values are strict (for no access outside of declared interfaces through plugs), devmode (for unrestricted access) or classic.
    # For more information, refer to https://snapcraft.io/docs/snap-confinement.
    #
    # Examples: strict, or devmode
    "confinement",

    # Type: string (mandatory)
    #
    # Multi-line description of the snap.
    #
    # A more in-depth look at what your snap does and who may find it most useful.
    "description",

    # Type: enum (optional)
    #
    # Defines the quality grade of the snap.
    #
    # Can be either
    #   devel (i.e. a development version of the snap, so not to be published to the stable or candidate channels).
    #   stable (i.e. a stable release or release candidate, which can be released to all channels).
    #
    # Example: [stable or devel]
    "grade",

    # Type: string (optional)
    #
    # Path to icon image that represents the snap in the snapcraft.io store pages and other graphical store fronts.
    #
    # Note that the desktop menu does not use this icon. It uses the icon in the .desktop file of the application.
    #
    # It is a relative path to a .png/.svg file from the source tree root. The recommended size is 256x256 pixels.
    # Aspect ratio needs to be 1:1. Image size can vary from 40x40 to 512x512 px and the file size should not be larger than 256 KB.
    #
    # Examples: _package_name_.svg, or snap/gui/logo.png
    "icon",  # ⚓

    # Type: string (optional)
    #
    # A license for the snap in the form of an SPDX expression for the license.
    #
    # In the legacy Snapcraft syntax (not using the base key), this key is only available through the passthrough key.
    #
    # Currently, only SPDX 2.1 expressions are supported. A list of supported values are also available at snapd/licenses.go at master · snapcore/snapd.
    #
    # For “or later” and “with exception” license styles refer to the Appendix IV of the SPDX Specification 2.1.
    #
    # Examples: GPL-3.0+, MIT, Proprietary
    "license",  # ⚓

    # Type: string (mandatory)
    #
    # The identifying name of the snap.
    #
    # It must start with an ASCII character and can only contain letters in lower case, numbers, and hyphens, and it can’t start or end with a hyphen.
    # The name must be unique if you want to publish to the Snap Store.
    #
    # For help on choosing a name and registering it on the Snap Store, see Registering your app name.
    #
    # Example: my-awesome-app
    "name",

    # Type: type[object] (optional)
    #
    # Attributes to passthrough to snap.yaml without validation from snapcraft.
    #
    # See https://snapcraft.io/docs/using-in-development-features for more details.
    #
    "passthrough",

    # Type: string (mandatory)
    #
    # Sentence summarising the snap.
    #
    # Max len. 78 characters, describing the snap in short and simple terms.
    #
    #   Example: The super cat generator
    "summary",

    # Type: string (optional)
    #
    # The canonical title of the application, displayed in the software centre graphical frontends.
    #
    # Max length 40 characters.
    #
    # In the legacy Snapcraft syntax (not using the base key), this key is only available through the passthrough key.
    #
    #   Example: My Awesome Application
    "title",

    # Type: enum (optional)
    #
    # The type of snap, implicitly set to app if not set.
    #
    # For more details, see:
    #    https://snapcraft.io/docs/gadget-snap,
    #    https://snapcraft.io/docs/kernel-snap,
    #    https://snapcraft.io/docs/base-snaps,
    # Example: [app|core|gadget|kernel|base]
    "type",

    # Type: string (mandatory)
    #
    # A user facing version to display.
    #
    # Max len. 32 chars. Needs to be wrapped with single-quotes when the value will be interpreted by the YAML parser as non-string.
    #
    # Examples: '1', '1.2', '1.2.3', git (will be replaced by a git describe based version string)
    #
    "version",

    # Plugs and slots for an entire snap
    # Plugs and slots for an interface are usually configured per-app or per-daemon within snapcraft.yaml.
    # See https://snapcraft.io/docs/snapcraft-app-and-service-metadata for more details.
    # However, snapcraft.yaml also enables global plugs and slots configuration for an entire snap:

    # Type: dict (optional)
    # These plugs apply to all apps and differs from apps.<app-name>.plugs in that the type is in a dict rather than a list format,
    # :(colon) must be postfixed to the interface name and shouldn’t start with -(dash-space).
    "plugs",

    # TODO Handle slots parsing (see below)
    # Type: dict (optional)
    #
    # A set of slots that the snap provides, applied to all the apps.
    "slots",
]

# TODO: handle plugs attribute
# plugs.<plug-name>
# Type: dict (optional)
#
# A set of attributes for a plug.
#
# Example: read attribute for the home interface.
#
# plugs.<plug-name>.<attribute-name>
# Type: string (optional)
#
# Value of the attribute.
# Example: all for read attribute of the home interface.


# slots.<slot-name>
# Type: dict
# (optional)
#
# A set of attributes of the slot.
#
# slots.<slot-name>.<attribute-name>
# Type: dict
# (optional)
#
# Value of the attribute.
# TODO: handle slot parsing.


# The app keys and values in snapcraft.yaml detail the applications and services that a snap wants to expose,
# including how they’re executed and which resources they can access.
# See Snapcraft top-level metadata and Snapcraft parts metadata for details on
# how apps and parts are configured within snapcraft.yaml.
#
# apps
# Type: dict
# A map of app-names representing entry points to run for the snap.
#
# apps.<app-name>
# Type: dict
# The name exposed to run a program inside the snap.
# If <app-name> is the same as name, the program will be invoked as app-name. However, if they differ,
# the program will be exposed as <snap-name>.<app-name>.
SNAP_MANIFEST_APP_TAGS = [
    # Type enum
    # Can be one of the following:
    #   none (Disables the creation of an env variable wrapper.)
    #   full (default)
    # Snapcraft normally creates a wrapper holding common environment variables. Disabling this could be useful for minimal base snaps without a shell, and for statically linked binaries with no use for an environment.
    "adapter",

    # Type: string
    # Defines the name of the .desktop file used to start an application with the desktop session.
    # The desktop file is placed in $SNAP_USER_DATA/.config/autostart, and the application is started using the app’s command wrapper (<name>.<app>) plus any argument present in the Exec= line within the .desktop file.
    #   Example: autostart: my-chat.desktop
    # See Autostart desktop files for an example of both the desktop file and the Exec file entry.
    "autostart⚓",

    # Type: string
    # The command to run inside the snap when <app-name> is invoked.
    # The command can be in either a snap runtime’s command path, $SNAP/usr/sbin:$SNAP/usr/bin:$SNAP/sbin:$SNAP/bin, or an executable path relative to $SNAP.
    # If daemon is set, this will be the command to run the service. Only a snap with classic confinement can use a relative path because PATH isn’t modified by a wrapper in classic confinement. See Classic confinement for more details.
    #   Examples: app-launch for an excecutable placed under $SNAP/bin. With classic confinement, bin/app-launch for an executable placed under $SNAP/bin.
    "command",

    # Type: Array of string
    # A list of command to be executed, in order, before the command referenced by apps.<app-name>.command.
    #   See Proposal: support command-chain in apps and hooks for further details.
    # To ensure that the Snapd distribution user running supports this feature, add the command-chain value to the assumes property.
    "command-chain",

    # Type: string
    # An identifier to a desktop-id within an external appstream file.
    # See Using external metadata for more details.
    "common-id",

    # Type: enum
    # Declares that <app-name> is a system daemon.
    # Can be one of the following:
    #   simple: the command is the main process.
    #   oneshot: the configured command will exit after completion
    #   forking: the configured command calls fork() as part of its start-up. The parent process is then expected to exit when start-up is complete
    #   notify: the command configured will send a signal to systemd to indicate that it’s running.
    "daemon",

    # Type: string
    # Location of the .desktop file.
    # A path relative to the prime directory pointing to a desktop file, commonly used to add an application to the launch menu. Snapcraft will take care of the rest.
    #   Examples: usr/share/applications/my-app.desktop and share/applications/my-app.desktop
    "desktop",

    # Type: dict
    # A set of key-value pairs specifying the contents of environment variables.
    # Key is the environment variable name; Value is the contents of the environment variable.
    #   Example: LANG: C.UTF-8
    "environment",

    # Type: list[string]
    # Extensions to apply to this application.
    #   Example: [gnome-3-28]
    "extensions",

    # Type: string
    # The socket abstract name or socket path.
    # Sockets should go to a map of <socket-name>\ to objects which specify the listen-stream and (optionally) the socket-mode.
    #
    # TCP socket syntax: <port>, [::]:<port>, [::1]:<port> and 127.0.0.1:<port>
    # UNIX socket syntax: $SNAP_DATA/<path>, $SNAP_COMMON/<path> and @snap.<snap name>.<suffix>
    #
    # Example:
    #     unix:
    #       listen-stream: $SNAP_COMMON/lxd/unix.socket
    #       socket-mode: 0660
    "listen-stream",

    # Type: type[object]
    # <app-name> attributes to pass through to snap.yaml without snapcraft validation.
    # See Using in-development features for further details.
    "passthrough",

    # Type: list[string]
    # Plugs for interfaces to connect to.
    # <app-name> will make these plug connections when running in strict confinement For interfaces that need attributes, see top-level plugs.
    #   Example: [home, removable-media, raw-usb]
    "plugs",

    # Type: string
    # Runs a command from inside the snap after a service stops.
    # Requires daemon to be set as the snap type.
    "post-stop-command",

    # Type: enum
    # Condition to restart the daemon under.
    # Defaults to on-failure. Other values are [on-failure|on-success|on-abnormal|on-abort|always|never]. Refer to systemd.service manual for details.
    # Requires daemon to be set as the snap type.
    "restart-condition",

    # Type: list[string]
    # Slots for interfaces to connect to.
    # <app-name> will make these slot connections when running in strict confinement only. For interfaces that need attributes, see top-level slots.
    #   Example: [home, removable-media, raw-usb]
    "slots",

    # Type: dict
    # Maps a daemon’s sockets to services and activates them.
    # Requires an activated daemon socket.
    # Requires apps.<app-name>.plugs to declare the network-bind plug.
    "socket",

    # Type: integer
    # The mode of a socket in octal.
    "socket-mode",

    # Type: string
    # The path to a command inside the snap to run to stop the service.
    # Requires daemon to be set as the snap type.
    "stop-command",

    # Type: string
    # The length of time to wait before terminating a service.
    # Time duration units can be 10ns, 10us, 10ms, 10s, 10m. Termination is via SIGTERM (and SIGKILL if that doesn’t work).
    # Requires daemon to be set as the snap type.
    "stop-timeout",

    # Type: timer-string
    # Schedules when, or how often, to run a service or command.
    # See Timer string format for further details on the required syntax.
    # Requires daemon to be set as the snap type.
    "timer",
]

if __name__ == '__main__':
    # TODO add argument parsing stuff.

    if len(sys.argv) < 2:
        sys.stderr.write("Usage: snap2flatpak snapcraft.yaml [options]")

    # Otherwise the format is JSON, as both formats are supported by Flatpak.
    format_is_yaml = True

    input_path = sys.argv[1]
    output_path = sys.argv[2]

    snap_manifest = yaml.load(open(input_path, 'r'))
    flatpak_manifest = {}

    if format_is_yaml:
        print(yaml.dump(
            flatpak_manifest,
            default_flow_style=False,
            explicit_start=True,
            allow_unicode=True,
        ))
    else:
        print(json.dump(
            flatpak_manifest,
            default_flow_style=False,
            explicit_start=True,
            allow_unicode=True,
        ))
